        ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
        █ Описание модуля MCGABase 2.6 █
┌───────▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀───────────────────────┘
        Предлагаемый  вашему  вниманию  модуль MCGA Base 2  (или
просто MB2) может быть полезен при написании программ,  работаю-
щих с графикой, опрашивающих мышь и/или клавиатуру.

	На  заре  MS DOS существовал графический стандарт MCGA с
разрешением 320*200 пикселей.  Этот модуль поможет вам как вклю-
чить этот режим, так и выжать из него максимум.

        Требования модуля к системе:

 ■ По состоянию на 2024 преимущественно для работы в DosBox.

 ■ Среда: Pascal-совместимая.

────────▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄────────────────────────────────┘
        █ Описание переменных █
┌───────▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀─────────────────────────────────
        В модуле используется десять переменных,  доступ к кото-
рым  возможен как непосредственно,  так и  с помощью специальных
процедур:

 ■ Gr256_Col: BYTE
        Хранит номер так называемого текущего цвета.
        Под текущим понимается  цвет,  используемый  процедурами
        Circle, Clear, Cls, Fill, Line, Linec, Print и Textxy.
        Устанавливается процедурой Color (c: BYTE), где c - зна-
        чение, присваиваемое Gr256_Col.

 ■ PixSizeX: BYTE
        Коэффициент масштабирования символов  по горизонтали для
        процедуры Print.  Устанавливается  процедурой  PrintSize
        (x, y: BYTE), где x - новое значение PixSizeX.

 ■ PixSizeY: BYTE
        Коэффициент  масштабирования символов  по вертикали  для
        процедуры Print.  Устанавливается  процедурой  PrintSize
        (x, y: BYTE), где y - новое значение PixSizeY.

Переменные PixSizeX и PixSizeY вместе определяют, во сколько раз
        будут растянуты символы при вызове процедуры Print в го-
        ризонтальном и вертикальном направлениях.
        Напомню,  что  процедура Print предназначена только  для
        графического режима.

 ■ Kp: BOOLEAN
        Обычно устанавливается посредством вызова процедуры Scan
        при нормальной обработке Int 16H.
        Если в буфере клавиатуры есть  код  какой-либо  клавиши,
        процедура Scan заносит в Kp значение TRUE. Если этот код
        является дополнительным, значение TRUE присваивается ещё
        и переменной Ek: BOOLEAN. Собственно код заносится в пе-
        ременную KeyV: BYTE.
        Если код нажатой клавиши не является дополнительным, пе-
        ременная Ek: BOOLEAN будет содержать значение FALSE.
        Если  же в буфере клавиатуры  не  окажется кода клавиши,
        значение FALSE присвоится переменной Kp.

 ■ Ek: BOOLEAN
        Обычно устанавливается процедурой Scan при  Kp=TRUE, как
        признак, является ли код нажатой клавиши дополнительным.
        Если клавиша не нажата и  Kp=FALSE, значение Ek не изме-
        няется.

 ■ KeyV: BYTE
        Обычно устанавливается процедурой Scan при Kp=TRUE.  Ис-
        пользуется для приёма кода нажатой клавиши. Если же кла-
        виша не была нажата, значение KeyV после вызова процеду-
        ры Scan не меняется.

 ■ Key_Left, Key_Right, Key_Up, Key_Down: BOOLEAN
        Устанавливаются процедурой Scan. Служат для отслеживания
        нажатия  пользователем клавиш "Влево", "Вправо", "Вверх"
        и "Вниз" соответственно.  Разовому нажатию клавиши соот-
        ветствует разовое снятие знчения  TRUE  после  отработки
        Scan.

Переменные Kp, Ek и KeyV вместе удобно использовать  для анализа
        поступающих с клавиатуры кодов.  Такой анализ может быть
        выполнен следующим образом:

                {Uses MB2}
                НАЧАЛО ЦИКЛА
                        Scan; {Опрос буфера клавиатуры}
                        If Kp then
                        BEGIN
                           {Kp=TRUE, => клавиша нажата}
                           If Ek then
                            BEGIN {Ek=TRUE, следовательно}
                               {принят дополнительный код}
                               Case KeyV of {Анализ кода}
                                   ...
                                  75: {Курсор влево};
                                  77: {Курсор вправо};
                                   ...
                               End
                            END
                           Else
                              BEGIN {Ek=FALSE, значит}
                                  {принят обычный код}
                                 Case KeyV of {Анализ кода}
                                    32: {Пробел};
                                    33: {Восклицательный знак};
                                     ...
                                    48..57: {Цифра};
                                     ...
                                 End
                        END
                        Else {Kp=FALSE, => Клавиша не нажата!};
                КОНЕЦ ЦИКЛА.

────────▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄───────────────────────────────┘
        █ Переключение режимов █
┌───────▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀────────────────────────────────
        Перед переключением режимов рекомендую запретить отобра-
жение курсора мыши процедурой Mhide,  если в Вашей программе ис-
пользуется мышь.

 ■ Procedure Igraph
        Включает графический режим 13H: 320x200, 256 цветов.

 ■ Procedure Clgraph
        Включает текстовый режим 03H: VGA, 80x25, шрифт 8x16.

────────▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄────────────────────────────────────────┘
        █ Функция SGN █
┌───────▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀─────────────────────────────────────────
 ■ Function Sgn (n: INTEGER): SHORTINT
        Возвращает знак аргумента.
        Sgn (-|X|) = -1;
        Sgn (0) = 0;
        Sgn (+|X|) = 1.

────────▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄──────────────────────────────────┘
        █ Базовые процедуры █
┌───────▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀───────────────────────────────────
 ■ Procedure Color (c: BYTE)
        Определяет номер текущего  цвета  для  процедур  Circle,
        Clear, Cls, Fill, Line, Print, Textxy.
        Присваивает переменной Gr256_Col значение c.
        Переменная Gr256_Col может принимать все значения из ди-
        апазона (0-255).

 ■ Procedure Waiting
        Возвращает управление вызывающей программе в момент, ко-
        гда луч ЭЛТ заканчивает прорисовку экрана и начинает об-
        ратный вертикальный ход.
        Процедура используется для синхронизации выводимой  гра-
        фики с частотой обновления экрана с целью предотвращения
        мерцания.

 ■ Procedure Border (c: BYTE)
        Определяет цвет границы экрана. В графическом режиме c -
        номер одного из двухсот пятидесяти шести цветов. В текс-
        товом режиме байт c имеет следующую структуру:

           c:   ┌────┬────┬────┬────┬────┬────┬────┬────┐
                │ __ │ __ │Крас│Зел │Син │Крас│Зел │Син │
                │    │    │втор│втор│втор│ осн│ осн│ осн│
                └────┴────┴────┴────┴────┴────┴────┴────┘
                  7    6    5    4    3    2    1    0
        "Оттенки" красного, зелёного и синего цветов определяют-
        ся двухбитными числами: ┌───┬────┐
                                │осн│втор│
                                └───┴────┘
                                  1   0
        Например,  Border ($24) в текстовом режиме сделает рамку
        экрана ярко-красной, т.к. $24 в двоичном виде: 00100100.

 ■ Procedure Setpal (cn, r, g, b: BYTE)
        Определяет составляющие оттенки красного  (r),  зелёного
        (g) и синего (b) цветов для цвета с номером cn (0-255).
        Значения оттенков - шестибитные и могут принимать значе-
        ния от нуля до шестидесяти трёх.
        Например, Setpal (0, 63, 0, 63) сделает цвет с номером 0
        ярко-розовым, так как смесь красного и синего оттенков в
        равном количестве даёт розовый цвет.

 ■ Procedure Getpal (cn: BYTE; VAR r, g, b: BYTE)
        Читает в переменные r, g и b оттенки красного (r), зеле-
        ного (g) и синего (b) цветов из цвета с номером cn.
        Может быть использована для анализа или различных видео-
        эффектов. Например, для эффекта вспышки:

                {Uses MB2;}
                {Var r, g, b, n, i: BYTE;}
                {Begin}
                 ...
                For i := 1 to 2 do
                   Begin
                      Waiting;
                      For n := 0 to 255 do
                         Begin
                            Getpal (n, r, g, b);
                            Setpal (n, r XOR 63, g XOR 63,
                                b XOR 63)
                         End;
                      Waiting
                   End;
                 ...

────────▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄──────────────────────────────┘
        █ Графические процедуры █
┌───────▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀───────────────────────────────
        Для всех процедур,  кроме Point,  Printsize и Pixmethod,
желательно,   чтобы  отображение  курсора  мыши  было  отключено
(Mhide).

 ■ Procedure Pixmethod (N: BYTE)
        Устанавливает один из следующих методов вывода графичес-
        ких пикселов в процедурах  Plot,  Line,  Circle,  Print,
        Putpixel, Linec:
                0: NORMAL - обычный вывод;
                1: XOR - наложение на имеющийся пиксел по XOR;
                2: OR - аналогично по OR;
                3: AND - по AND;
                4: NOT - инверсия имеющегося пиксела;
                5: INC - увеличение значения на единицу;
                6: DEC - уменьшение на единицу;
                7: DISABLE - вывод запрещён.
        В методах 4, 5, 6 и 7 значение Gr256_Col игнорируется.

 ■ Procedure Plot (x, y: INTEGER; cn: BYTE)
        Выводит на экран пиксел цветом с номером cn.
        Проверка допустимости значений координат не производится
        для повышения скорости.

 ■ Procedure Putpixel (x, y: INTEGER; cn: BYTE)
        Аналогична процедуре Plot, но проверяет значения коорди-
        нат пиксела и, если пиксел не вписывается в экран, прос-
        то возвращает управление вызывающей программе.

 ■ Function Point (x, y: INTEGER): BYTE
        Возвращает номер цвета пиксела с координатами (x, y).
        Значения координат не проверяются на допустимость.

 ■ Procedure Line (x1, y1, x2, y2: INTEGER)
        Рисует линию методом Брезенхема, то есть очень быстро.
        Значения координат не проверяются на допустимость.
        Цвет линии определяется процедурой Color (cn: BYTE).

 ■ Procedure Linec (x1, y1, x2, y2: INTEGER)
        Отличается от Line методом расчёта адреса выводимого пи-
        кселя.  Метод,  применённый в этой процедуре,  расходует
        в 1,2 - 2,0 больше машинных тактов,  но позволяет прове-
        рять координаты выводимого пиксела и пропускать его, ес-
        ли он не попадает в экран.

 ■ Procedure Circle (x, y, r: INTEGER)
        Рисует окружность радиуса r методом Брезенхема.
        Значения  координат  каждой точки окружности проверяются
        на допустимость и если точка оказывается вне экрана, она
        просто не выводится.
        Цвет окружности определяется процедурой Color (c: BYTE).

 ■ Procedure Print (x, y: INTEGER; s: STRING)
        Выводит на экран текст из строки  s,  начиная  с позиции
        (x, y)  в  масштабе   1 : PixSizeX -  по  горизонтали  и
        1 : PixSizeY - по вертикали. PixSizeX и PixSizeY - пере-
        менные  типа  BYTE, устанавливаемые процедурой PrintSize
        (x, y: BYTE).
        Цвет текста определяется процедурой Color (cn: BYTE).
        Координаты каждого выводимого на экран пиксела  проверя-
        ются на допустимость, и  если пиксел оказывается вне эк-
        рана, он просто не выводится.

 ■ Procedure Printsize (x, y: BYTE)
        Определяет масштаб текста, выводимого процедурой Print.
        Устанавливает переменные PixSizeX и PixSizeY, присваивая
        им значения x и y соответственно.
        Переменные PixSizeX и PixSizeY могут принимать  значения
        от единицы до двухсот пятидесяти пяти.

 ■ Procedure Cls
        Очищает весь экран,  заполняя его цветом,  установленным
        процедурой Color.

 ■ Procedure Clear (x1, y1, x2, y2: INTEGER)
        Очищает окно, заданное двумя точками:
                (x1, y1) - левая верхняя точка окна;
                (x2, y2) - правая нижняя точка.
        Можно иначе: (x1, y1) - левая нижняя,
                     (x2, y2) - правая верхняя.
        В любом случае (x1, y1, x2, y2) - одна из диагоналей ок-
        на.
        Вся указанная область заполнится  цветом,  установленным
        процедурой Color (cn: BYTE).

 ■ Procedure Fill (x, y: INTEGER)
        Заполняет контур, включающий точку (x, y), цветом, уста-
        новленным процедурой Color (cn: BYTE).
        Границей контура являются точки, имеющие цвет,  отличный
        от цвета точки (x, y).
        Процедура может вызвать зависание  компьютера,  если  не
        определены верхняя и левая границы контура.
        При заполнении используется машинный стек,  так  что при
        компиляции программы советую не ограничивать размер сте-
        ка, а отвести под него специальный сегмент на 64K.

 ■ Procedure Vset (o: WORD)
        Устанавливает позицию начала экрана в видеосегменте.  По
        умолчанию смещение равно нулю и точка (0, 0)  соответст-
        вует левой верхней точке экрана.
        При использовании имейте в виду, что увеличение смещения
        на  единицу соответствует смещению позиции начала экрана
        на четыре пиксела.
        Таким образом, для "скроллинга" экрана вверх на один пи-
        ксел необходимо увеличить смещение  не  на 320 единиц, а
        всего лишь на 80.
        Также не следует забывать,  что  экран в режиме VGA/MCGA
        13H: 320x200, 256 цветов занимает не 64K,  а 64000 байт,
        так что за экраном в видео-сегменте находится  еще  1536
        байт, которые выведутся на экран, если изменить соответ-
        ствующим образом смещение.
        Программа для "скроллинга" экрана может  выглядеть  при-
        мерно так:

                Uses MB2;
                Var W: WORD;
                Begin
                   Igraph;
                   Circle (159, 99, 99);
                   W := 0;
                   Repeat
                      Waiting;
                      Vset (W);
                      W := (W + 80) AND $3FFF
                   Until Key;
                   Clgraph
                End.

────────▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄────────────────────────────┘
        █ Обслуживание клавиатуры █
┌───────▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀─────────────────────────────
 ■ Function Key: BYTEBOOL
        Возвращает значение TRUE, если пользователь нажал какую-
        нибудь клавишу, код  которой изымается процедурой из бу-
        фера клавиатуры, но не сохраняется за ненадобностью.
        Если пользователь ничего не нажимал, процедура возвраща-
        ет значение FALSE.
        Функция не возвращает кода нажатой клавиши; если необхо-
        димо получить код, - воспользуйтесь процедурой Scan.
        Функция обычно применяется в циклах с выходом  по  любой
        клавише. Пример цикла: Repeat ... Until Key.

 ■ Procedure Scan
        Процедура опрашивает буфер клавиатуры и если он пуст (то
        есть, пользователь ничего не нажал на клавиатуре), прис-
        ваивает переменной Kp значение FALSE и возвращает управ-
        ление вызывающей программе.
        Если буфер не пустой, процедура изымает код нажатой кла-
        виши и устанавливает переменную Ek (признак дополнитель-
        ного кода) в соответствии с тем,  является  ли  этот код
        дополнительным.
        Сам код заносится процедурой в переменную Keyv.
        В разделе описания переменных приведён пример  опроса  и
        анализа кодов с помощью процедуры Scan.

 ■ Procedure Pause
        Ждёт нажатия пользователем любой клавиши,  имеющей ASCII
        или дополнительный код, после чего возвращает управление
        вызывающей программе.

────────▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄────────────────────────────┘
        █ Работа с драйвером мыши █
┌───────▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀─────────────────────────────
 ■ Function Rmouse: BOOLEAN
        Проверяет наличие драйвера мыши.
        Работа с мышью с использованием процедур модуля невозмо-
        жна, если функция возвращает значение  FALSE,  поскольку
        в этом случае драйвер мыши скорее всего не инициализиро-
        ван или находится в неактивном состоянии.

 ■ Procedure Mshow
        Разрешает отображение курсора мыши.
        Вид курсора зависит от драйвера, но обычно это спрайт со
        стрелочкой в графическом режиме  и  изменённый  функцией
        XOR цветовой атрибут в текстовом.
        Перед переключением видео-режимов, выводом графики и/или
        текста, а также перед завершением работы программы реко-
        мендую запретить отображение курсора процедурой Mhide.

 ■ Procedure Mhide
        Запрещает разрешённое процедурой Mshow отображение  кур-
        сора мыши.

 ■ Function Lp: BOOLEAN
        Возвращает состояние левой кнопки мыши:  TRUE - кнопка в
        нажатом состоянии, FALSE - кнопка не нажата.

 ■ Function Rp: BOOLEAN
        Работает аналогично функции Lp, но для правой кнопки мы-
        ши.

 ■ Procedure Mwaitoff
        Процедура возвращает управление вызывающей программе то-
        гда и только тогда, когда обе кнопки мыши окажутся в не-
        нажатом состоянии.
        Будьте внимательны, используя эту процедуру, так как она
        может вызвать сбой некоторых драйверов мыши,  написанных
        некорректно, что приводит к зависанию компьютера.
        Вызов этой процедуры при отсутствии  в  системе драйвера
        мыши приведёт к непредсказуемому результату! Обязательно
        проверьте наличие драйвера, вызвав функцию Rmouse.

 ■ Procedure Mset (x, y: INTEGER)
        Процедура принудительно перемещает курсор мыши в позицию
        (x, y).

 ■ Procedure Mcrd (VAR x, y: INTEGER)
        Процедура возвращает координаты курсора мыши.
        Если пределы перемещения курсора мыши не были  изменены,
        то обычно возвращаются координаты в  матрице  (640x200).
        Изменить пределы можно процедурами Mxr (x1, x2: INTEGER)
        и Myr (y1, y2: INTEGER).
        Следует помнить, что обычно драйвер мыши  при  работе  в
        текстовом режиме сам обнуляет младшие биты координат, не
        имеющие смысла, и получается, что положение курсора  из-
        меняется скачкообразно.  Например, по x: 160, 128, 120 и
        так далее, но младшие три бита всегда сброшены в ноль.

 ■ Procedure Mxr (x1, x2: INTEGER)
        Устанавливает  пределы перемещения курсора мыши по гори-
        зонтали: x1 - левый предел, x2 - правый.
        Бывает полезна  для ограничения перемещений курсора мыши
        в пределах какого-нибудь прямоугольника.
        Возможно также использование для увеличения пределов, не
        ограничивающихся пределами экрана. Например, для исполь-
        зования мыши в графическом режиме 800x600.

 ■ Procedure Myr (y1, y2: INTEGER)
        Работает аналогично процедуре Mxr, но устанавливает пре-
        дел по вертикали: y1 - граница сверху, y2 - граница сни-
        зу.

 ■ Procedure Mpage (p: WORD)
        В текстовом режиме определяет видео-страницу для  вывода
        курсора мыши.
        Обычно номер этой страницы - ноль и совсем  не  требует,
        чтобы его изменяли. Я этой процедурой ни разу не пользо-
        вался и теперь сам уже не совсем понимаю, зачем она нуж-
        на.

────────▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄────────────────────────────────────┘
        █ Текстовый режим █
┌───────▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀─────────────────────────────────────
 ■ Procedure Chide
        Выключает мерцающий курсор в текстовом режиме.
        Чтобы его включить обратно, можно воспользоваться проце-
        дурой Cshow.

 ■ Procedure Cshow
        Включает мерцающий курсор в текстовом  режиме,  если  он
        ещё не включен.

 ■ Procedure Textxy (x, y: INTEGER; s: STRING)
        Выводит текст, содержащийся в строке s,  начиная с пози-
        ции (x, y).
        Возможные значения x: (0..79), y: (0..25).
        Цвет устанавливается процедурой Color (cn: BYTE), где cn
        определяет цвет, фон, яркость и мерцание символов в тек-
        стовом режиме:
           cn:  ┌────┬────┬────┬────┬────┬────┬────┬────┐
                │Мерц│ Rф │ Gф │ Bф │Ярк │ Rс │ Gс │ Bс │
                │1=вк│   цвет фона  │   цвет символов   │
                └────┴────┴────┴────┴────┴────┴────┴────┘
                  7    6    5    4    3    2    1    0
        Здесь Rф, Gф и Bф - красный, зелёный  и  синий цвета для
        фона, Rс, Gс и Bс - то же самое для символов.  Если  бит
        яркости установить в единицу,  символы выведутся с повы-
        шенной яркостью.
        Если установить старший бит,  выведенные  символы  будут
        мерцать.

────────▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄─────────────────────────────────┘
        █ Начальные значения █
┌───────▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀──────────────────────────────────
        При  запуске  программы  всегда происходит инициализация
переменных модуля:

        Gr256_Col := 15;
        Kp := 0;
        Ek := 0;
        KeyV := 0;
        key_left, key_right, key_up, key_down := 0;
        PixSizeX := 1;
        PixSizeY := 1.

        Кроме того, автоматически вызывается Pixmethod (0).

────────▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄───────────────────────────────────┘
        █ История развития █
┌───────▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀────────────────────────────────────
 ■ Версия 2.6 от 03.11.2024 (Hacker KAY):
    [+] Текст сконверчен в UTF-8.
    [+] Реструктуризация и минорные апдейты.

 ■ Версия 2.051 от 22.05.2002 (Hacker KAY):
    [!] Добавлены  переменные  key_left,  key_right,  key_up   и
        key_down, устанавливаемые процедурой Scan.
    [+] Автоматическое выполнение Pixmethod(0) в момент запуска.

 ■ Версия 2.05 от ??.??.2000 (Hacker KAY):
    [!] До этого момента история развития покрыта мраком неизве-
        стности.

────────▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄──────────────────────────────────────┘
        █ Авторы модуля █
┌───────▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀───────────────────────────────────────
Идея создания модуля:   Шиляев Александр Александрович
                        Елисеев Константин Александрович
                        Шишкин Дмитрий Анатольевич
                        Козин Максим Александрович

Алгоритмирование:       Елисеев К. А.
                        Майшев Алексей Владимирович
                        Краснопольская Татьяна Николаевна
                        Шишкин Д. А.
                        Козин М. А.
                        Кондратьев Дмитрий Александрович

Кодирование:            Елисеев К. А.
                        Шишкин Д. А.

Тестирование:           Елисеев К. А.
                        Шишкин Д. А.
                        Майшев А. В.
                        Козин М. А.
                        Краснопольская Т. Н.

Применение:             Елисеев К. А.
                        Шишкин Д. А.
                        Беринцев Денис Владимирович
                        Козин М. А.
                        Кондратьев Д. А.
                        Майшев А. В.
                        Краснопольская Т. Н.

Информ. обеспечение:    Шиляев А. А.
                        Майшев А. В.

Критика:                Шиляев Ю. А.
                        Шиляев А. А.
                        Козин М. А.

Реализация:             Елисеев К. А.
                        Шишкин Д. А.

Copyrights:             (C) 1998...2002 NUCLEAR INC. includes:

        Со всеми вопросами, пожеланиями и предложениями Вы може-
те обратиться по Contact EMail: <nuclear@udm.net>.

           Елисеев К. А.        -  Hacker KAY
           Шишкин Д. А.         -  Illuminator
           Кондратьев Д. А.     -  Demon
           Козин М. А.          -  Digital Maker

        Данное описание подготовил Hacker KAY в текстовом редак-
торе Borland Turbo Pascal 7.0.

        22.09.2002.                             г. Ижевск

────────▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄────────────────────────────────────────┘
        █ End of File █
        ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
